;;; -*- Mode: LISP; slime-proxy-proxy-connection: t -*-
(in-package :ps)

;;; Variables and constants
(defvar *canvas*)
(defvar *context*)
(defvar *map*)
(defvar *money*)
(defvar *turn*)
(defvar *city*)
(defvar *home*)

(defvar +colors+
  '((:grass-1 "#180")
    (:grass-2 "#291")
    (:grass-3 "#3C2")
    (:grass-4 "#190")
    (:grass-5 "#5D3")
    (:mud-1 "#531")
    (:mud-2 "#543")
    (:mud-3 "#364")
    (:city "#00F")
    (:home "#F00")))
(defvar +tile-size+ 10)
(defvar +initial-money+ 100)
(defvar +city-factor+ 0.005)

;;; Utils
(defun first (l)
  (elt l 0))
(defun second (l)
  (elt l 1))

(defun assoc (val list)
  ((@ list reduce)
   (lambda (last x)
     (if (and (not last) (= (first x) val))
         (second x)
         last))
   nil))

(defun mapcar (fun &rest as)
  (let ((result-array (make-array)))
    (if (= 1 (length as))
        (dolist (element (aref as 0))
          (result-array.push (fun element)))
        (dotimes (i (length (aref as 0)))
          (let ((args-array (mapcar (lambda (a) (return (aref a i))) as)))
            (result-array.push (fun.apply fun args-array)))))
    (return result-array)))

(defun get-time ()
  ;; The - before date is necessary here to have a capital in compiled code
  (let* ((date (new -date))
         (hours ((@ date get-hours)))
         (minutes ((@ date get-minutes)))
         (seconds ((@ date get-seconds))))
    (stringify
     (when (< hours 10) "0") hours ":"
     (when (< minutes 10) "0") minutes ":"
     (when (< seconds 10) "0") seconds)))

;;; Turns
(defun next-turn ()
  (setf *turn* (+ *turn* 1))
  (message (stringify "Starting turn " *turn*))
  (display-infos))

(defun init-turns ()
  (setf *turn* 0))

;;; Actions and messages
(defun clear-actions ()
  ((@ ($ "#actions") html) ""))

(defun add-action (id name fun)
  ((@ ($ "#actions") append)
   (ps-html ((:input :type "button" :id id :value name))))
  ((@ ($ (stringify "#" id)) click) fun))

(defun init-messages (str)
  ((@ ($ "#messages") html) ""))

(defun message (str)
  ((@ ($ "#messages") prepend)
   (stringify (get-time) "> " str "<br/>")))

;;; Money
(defun pay (price)
  (if (> price *money*)
      (progn
        (message "You can't afford that !")
        false)
      (progn
        (setf *money* (- *money* price))
        (display-infos)
        t)))

(defun earn (money)
  (setf *money* (+ *money* money)))

(defun init-money ()
  (setf *money* +initial-money+))

;;; Tiles
(defun tile-color (tile)
  (assoc tile +colors+))

(defun tile-position (pos)
  (floor (/ pos +tile-size+)))

(defun random-tile ()
  (first (elt +colors+ (random (- (@ +colors+ length) 2)))))

(defun draw-tile (x y type owned-p)
  (let* ((left (* x +tile-size+)) (right (+ left +tile-size+))
         (top (* y +tile-size+)) (bottom (+ top +tile-size+)))
    (setf (@ *context* fill-style) (tile-color type))
    ((@ *context* fill-rect) left top right bottom)
    (when owned-p
      (setf (@ *context* stroke-style) "#F00")
      ((@ *context* begin-path))
      ((@ *context* move-to) left top)
      (mapcar (lambda (x y) ((@ *context* line-to) x y))
              (list left right right left left)
              (list top top bottom bottom top))
      ((@ *context* stroke)))))

(defun tile-handle-click (type map x y)
  (clear-actions)
  (case type
    ((:grass-1 :grass-2 :grass-3 :grass-4 :grass-5 :mud-1 :mud-2 :mud-3)
     (if (owned map x y)
         (add-action "sell" "Sell at 10"
                     (lambda ()
                       (earn 10)
                       (message "Sold field")
                       (set-owned map x y false)
                       (redraw)
                       (clear-actions)))
         (when (and (= *city* *home*) (can-buy-field map x y))
           (add-action "buy" "Buy (costs 10)"
                       (lambda ()
                         (when (pay 10)
                           (message "Buying field")
                           (set-owned map x y)
                           (redraw))
                         (clear-actions))))))
    (:city
     (let ((city (city map x y)))
       (add-action "go" (stringify "Go to " (@ city name))
                   (lambda ()
                     (go-to city)
                     (clear-actions)))))
    (:home
     (add-action "go" (stringify "Go home")
                 (lambda ()
                   (go-to *home*)
                   (clear-actions))))))

;;; Cities
(defun make-city (x y)
  (create type "city" :name (make-city-name) :x x :y y))

(defun check-adjacent-cases (fun map x y)
  (try
   (progn
     (dolist (pos-x (list (- x 1) x (+ x 1)))
       (dolist (pos-y (list (- y 1) y (+ y 1)))
         (when (and (not (and (= pos-x x) (= pos-y y)))
                    (>= pos-x 0) (>= pos-y 0)
                    (< pos-x (@ map width))
                    (< pos-y (@ map height)))
           (unless (fun pos-x pos-y)
             (throw "end")))))
     true)
   (:catch (error)
     (return false))))

(defun can-place-city (map x y)
  (flet ((check (x y)
           (if (and (>= x 0) (>= y 0)
                    (< x (@ map width)) (< y (@ map height)))
               (not (= (tile-type map x y) :city)))))
    (and (not (= (tile-type map x y) :city))
        (check-adjacent-cases check map x y))))

(defun can-buy-field (map x y)
  (and
   (not (owned map x y))
   (not (check-adjacent-cases (lambda (x y)
                                (not
                                 (or (= (tile-type map x y) :home)
                                     (owned map x y))))
                              map x y))))

(defun add-cities (map)
  (labels ((helper (n)
             (when (>= n 0)
               (let ((x (random (@ map width)))
                     (y (random (@ map height))))
                 (if (can-place-city map x y)
                     (progn
                       (set-city map x y (make-city x y))
                       (helper (- n 1)))
                     (helper n))))))
    (helper (floor (* +city-factor+ (@ map width) (@ map height))))))

(defun add-home (map)
  (labels ((helper ()
             (let ((x (random (@ map width)))
                   (y (random (@ map height))))
               (if (can-place-city map x y)
                   (progn
                     (setf *home* (create type "home" :name "Home" :x x :y y))
                     (set-home map x y))
                   (helper)))))
    (helper)))

(defun go-to (city)
  (if (= city *home*)
      (message "Home sweet home")
      (message (stringify "Going to " (@ city name))))
  (setf *city* city)
  (display-infos)
  (next-turn))

(defun init-cities ()
  (add-home *map*)
  (setf *city* *home*))

;;; Maps
(defun set-home (map x y)
  (set-tile-type map x y :home))

(defun set-city (map x y city)
  (setf (aref (@ map cities) x y) city)
  (set-tile-type map x y :city))

(defun city (map x y)
  (aref (@ map cities) x y))

(defun set-owned (map x y &optional (status t))
  (setf (aref (@ map owned) x y) status))

(defun owned (map x y)
  (aref (@ map owned) x y))

(defun set-tile-type (map x y type)
  (setf (aref (@ map contents) x y) type))

(defun tile-type (map x y)
  (aref (@ map contents) x y))

(defun map-width (map)
  (@ map width))

(defun map-height (map)
  (@ map height))

(defun make-map (w h)
  (let ((contents (make-array))
        (owned (make-array))
        (cities (make-array)))
    (dotimes (x w)
      (setf (aref contents x) (make-array))
      (setf (aref owned x) (make-array))
      (setf (aref cities x) (make-array))
      (dotimes (y h)
        (setf (aref contents x y) (random-tile))
        (setf (aref owned x y) nil)))
    (create type "map"
            :width w :height h
            :contents contents :owned owned
            :cities cities)))


(defun new-map ()
  (let ((map
         (make-map (/ ((@ *canvas* width)) +tile-size+)
                   (/ ((@ *canvas* height)) +tile-size+))))
    (add-cities map)
    map))

(defun map-foreach (f map)
  (dotimes (x (@ map width))
    (dotimes (y (@ map height))
      (f x y))))

(defun draw-map (map)
  (let ((borders-func (make-array)))
    (map-foreach (lambda (x y)
                   (draw-tile x y
                              (tile-type map x y)
                              (owned map x y)))
                 map)))

(defun init-map ()
  (setq *map* (new-map)))

;;; Game
(defun handle-click (x y)
  (tile-handle-click (tile-type *map* x y) *map* x y))

(defun clear ()
  ((@ *context* clear-rect) 0 0 ((@ *canvas* width)) ((@ *canvas* height)))
  ((@ ($ "#infos") html) ""))

(defun display-infos ()
  ((@ ($ "#infos") html) (stringify "Money: " *money* " - "
                                    "Turn: " *turn* " - "
                                    "Location: " (@ *city* name))))

(defun pre-init ()
  ((@ *canvas* click)
   (lambda (e)
     (handle-click
      (tile-position (- (@ e page-x) (@ this offset-left)))
      (tile-position (- (@ e page-y) (@ this offset-top)))))))

(defun redraw ()
  (clear)
  (display-infos)
  (draw-map *map*))

(defun init ()
  (setq *canvas* ($ "#canvas"))
  (setq *context* ((@ (getprop *canvas* 0) get-context) "2d"))
  (pre-init)
  (clear)
  (clear-actions)
  (add-action "new" "New Game"
              (lambda ()
                (message "New game started")
                (init-messages)
                (init-money)
                (init-turns)
                (init-map)
                (init-cities)
                (clear-actions)
                (redraw))))

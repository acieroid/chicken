;;; -*- Mode: LISP; slime-proxy-proxy-connection: t -*-
(in-package :ps)

;;; Variables and constants
(defvar *canvas*)
(defvar *context*)
(defvar *map*)

(defvar +colors+
  '((:grass "#180")
    (:mud "#531")
    (:water "#47F")))
(defvar +tile-size+ 30)

;;; Utils
(defun first (l)
  (elt l 0))
(defun second (l)
  (elt l 1))

(defun assoc (val list)
  ((@ list reduce)
   (lambda (last x)
     (if (and (not last) (= (first x) val))
         (second x)
         last))
   nil))

(defun mapcar (fun &rest as)
  (let ((result-array (make-array)))
    (if (= 1 (length as))
        (dolist (element (aref as 0))
          (result-array.push (fun element)))
        (dotimes (i (length (aref as 0)))
          (let ((args-array (mapcar (lambda (a) (return (aref a i))) as)))
            (result-array.push (fun.apply fun args-array)))))
    (return result-array)))

;;; Actions
(defun clear-actions ()
  ((@ ($ "#actions") html) ""))

(defun add-action (id name fun)
  ((@ ($ "#actions") append)
   (ps-html ((:input :type "button" :id id :value name))))
  ((@ ($ (stringify "#" id)) click) fun))

;;; Tiles
(defun tile-color (tile)
  (assoc tile +colors+))

(defun tile-position (pos)
  (floor (/ pos +tile-size+)))

(defun random-tile ()
  (first (elt +colors+ (random (@ +colors+ length)))))

(defun draw-tile (x y type owned-p)
  (let* ((left (* x +tile-size+)) (right (+ left +tile-size+))
         (top (* y +tile-size+)) (bottom (+ top +tile-size+)))
    (setf (@ *context* fill-style) (tile-color type))
    ((@ *context* fill-rect) left top right bottom)
    (when owned-p
      (setf (@ *context* stroke-style) "#F00")
      ((@ *context* begin-path))
      ((@ *context* move-to) left top)
      (mapcar (lambda (x y) ((@ *context* line-to) x y))
              (list left right right left left)
              (list top top bottom bottom top))
      ((@ *context* stroke)))))

(defun tile-handle-click (type map x y)
  (clear-actions)
  (case type
    (:grass
     (add-action "buy" "Buy" (lambda ()
                               (setf (aref (@ map owned) x y) t)
                               (redraw)
                               (clear-actions))))))

;;; Maps
(defun make-map (w h)
  (let ((contents (make-array))
        (owned (make-array)))
    (dotimes (x w)
      (setf (aref contents x) (make-array))
      (setf (aref owned x) (make-array))
      (dotimes (y h)
        (setf (aref contents x y) (random-tile))
        (setf (aref owned x y) nil)))
    (create type "map"
            :width w :height h
            :contents contents :owned owned)))

(defun new-map ()
  (make-map (/ ((@ *canvas* width)) +tile-size+)
            (/ ((@ *canvas* height)) +tile-size+)))

(defun map-foreach (f map)
  (dotimes (x (@ map width))
    (dotimes (y (@ map height))
      (f x y))))

(defun draw-map (map)
  (let ((borders-func (make-array)))
    (map-foreach (lambda (x y)
                   (draw-tile x y
                              (aref (@ map contents) x y)
                              (aref (@ map owned) x y)))
                 map)))

;;; Game
(defun handle-click (x y)
  (tile-handle-click (aref (@ *map* contents) x y) *map* x y)
  (redraw))

(defun clear ()
  ((@ *context* clear-rect) 0 0 ((@ *canvas* width)) ((@ *canvas* height))))

(defun redraw ()
  (clear)
  (draw-map *map*))

(defun init ()
  (setq *canvas* ($ "#canvas"))
  (setq *context* ((@ (getprop *canvas* 0) get-context) "2d"))
  (clear)
  ((@ ($ "#content") html)
   (ps-html ((:input :type "button" :value "New Game"
                     :onclick (ps-inline
                               (progn
                                 (setq *map* (new-map))
                                 (draw-map *map*)))))))
  ((@ *canvas* click)
   (lambda (e)
     (handle-click
      (tile-position (- (@ e page-x) (@ this offset-left)))
      (tile-position (- (@ e page-y) (@ this offset-top)))))))

